name: 'Deploy Infrastructure (Multi-Region)'

on:
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy

permissions:
  id-token: write
  contents: read

env:
  TF_VERSION: '1.5.0'
  WORKING_DIRECTORY: './terraform'
  TF_VAR_environment: 'prod'
  TF_VAR_app_service_plan_sku: 'B1'
  TF_VAR_app_service_plan_tier: 'Basic'
  TF_VAR_min_instances: '1'
  TF_VAR_max_instances: '3'
  TF_VAR_health_check_path: '/health'
  TF_VAR_alert_email: 'haripriyaveluchamy@aity.dev'
  TF_VAR_log_retention_days: '30'
  TF_VAR_existing_resource_group_name: 'vibetrader-RAG-rg'
  
  # App settings
  TF_VAR_app_settings: |
    {
      WEBSITES_ENABLE_APP_SERVICE_STORAGE = "false"
      WEBSITES_PORT = "8000"
      SCM_DO_BUILD_DURING_DEPLOYMENT = "true"
      ENABLE_ORYX_BUILD = "true"
      PYTHON_VERSION = "3.12"
      ENVIRONMENT = "production"
      HEALTH_CHECK_ENABLED = "true"
      API_HOST = "0.0.0.0"
      API_PORT = "8000"
      AZURE_OPENAI_API_VERSION = "2024-02-01"
      AZURE_OPENAI_EMBEDDING_MODEL = "text-embedding-3-large"
      EMBEDDING_DIMENSION = "3072"
      QDRANT_COLLECTION_NAME = "news_articles"
      CACHE_TTL = "3600"
      DEFAULT_ARTICLE_LIMIT = "50"
      MAX_ARTICLE_CONTENT_CHARS = "10000"
      MAX_CHUNK_SIZE = "1000"
      SUMMARY_CACHE_SIZE = "1000"
      SUMMARY_CACHE_TTL = "3600"
    }

jobs:
  terraform:
    name: 'Terraform Multi-Region'
    runs-on: ubuntu-latest
    environment: production
    
    defaults:
      run:
        shell: bash
        working-directory: ${{ env.WORKING_DIRECTORY }}
    
    outputs:
      traffic_manager_url: ${{ steps.terraform_outputs.outputs.traffic_manager_url }}
      us_app_service_name: ${{ steps.terraform_outputs.outputs.us_app_service_name }}
      europe_app_service_name: ${{ steps.terraform_outputs.outputs.europe_app_service_name }}
      india_app_service_name: ${{ steps.terraform_outputs.outputs.india_app_service_name }}
      resource_group_name: ${{ steps.terraform_outputs.outputs.resource_group_name }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    # Set up environment variables for direct Terraform authentication
    - name: Set Terraform Environment Variables
      run: |
        # Create credentials file for Terraform Azure authentication
        echo "Setting up Azure environment variables for Terraform"
        
        # Export Azure credentials as environment variables
        echo "ARM_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID }}" >> $GITHUB_ENV
        echo "ARM_TENANT_ID=${{ secrets.AZURE_TENANT_ID }}" >> $GITHUB_ENV
        echo "ARM_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }}" >> $GITHUB_ENV
        
        # Get access token for Azure CLI authentication
        ACCESS_TOKEN=$(az account get-access-token --query accessToken -o tsv)
        echo "ARM_ACCESS_TOKEN=${ACCESS_TOKEN}" >> $GITHUB_ENV
        
        # Also get a storage-specific token
        STORAGE_TOKEN=$(az account get-access-token --resource https://storage.azure.com/ --query accessToken -o tsv)
        echo "ARM_SAS_TOKEN=${STORAGE_TOKEN}" >> $GITHUB_ENV

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Init
      run: |
        # Initialize with backend configuration
        terraform init \
          -backend-config="client_id=${{ secrets.AZURE_CLIENT_ID }}" \
          -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
          -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
          -backend-config="resource_group_name=${{ secrets.TERRAFORM_STATE_RG }}" \
          -backend-config="storage_account_name=tfstatevraag" \
          -backend-config="container_name=terraform-state" \
          -backend-config="key=newsraag-${TF_VAR_environment}.tfstate"

    # Handle autoscale settings issue - for both apply and destroy
    - name: Handle Autoscale Settings
      run: |
        # Common setup
        RESOURCE_GROUP="${{ env.TF_VAR_existing_resource_group_name }}"
        echo "Managing autoscale settings in $RESOURCE_GROUP..."
        
        # Define regions and autoscale names
        declare -A MODULE_PATHS=(
          ["us"]="module.app_services[\"us\"].azurerm_monitor_autoscale_setting.main"
          ["eu"]="module.app_services[\"europe\"].azurerm_monitor_autoscale_setting.main"
          ["in"]="module.app_services[\"india\"].azurerm_monitor_autoscale_setting.main"
        )
        
        # Check for existing autoscale settings
        for REGION in "us" "eu" "in"; do
          AUTOSCALE_NAME="autoscale-newsraag-${REGION}-prod"
          echo "Checking for $AUTOSCALE_NAME..."
          
          AUTOSCALE_ID=$(az monitor autoscale setting show --name $AUTOSCALE_NAME --resource-group $RESOURCE_GROUP --query id -o tsv 2>/dev/null || echo "")
          
          if [ -n "$AUTOSCALE_ID" ]; then
            echo "Found existing autoscale setting: $AUTOSCALE_NAME"
            
            if [ "${{ github.event.inputs.action }}" == "destroy" ]; then
              # For destroy: Delete the autoscale setting directly
              echo "Deleting autoscale setting $AUTOSCALE_NAME before destroy..."
              az monitor autoscale setting delete --name $AUTOSCALE_NAME --resource-group $RESOURCE_GROUP --yes
            else
              # For apply/plan: Import the resource into Terraform state
              echo "Importing $AUTOSCALE_NAME into Terraform state..."
              terraform import ${MODULE_PATHS[$REGION]} $AUTOSCALE_ID || echo "Import failed, continue anyway"
            fi
          else
            echo "No existing autoscale setting found for $AUTOSCALE_NAME"
          fi
        done

    - name: Terraform Plan
      if: github.event.inputs.action != 'destroy'
      run: |
        # Run plan with refresh-only first to update state with imported resources
        echo "Refreshing Terraform state..."
        terraform plan -refresh-only -input=false -out=tfrefresh
        terraform apply -auto-approve tfrefresh
        
        # Now create the actual plan
        echo "Creating deployment plan..."
        terraform plan -out=tfplan

    - name: Terraform Apply
      if: github.event.inputs.action == 'apply' || (github.event_name == 'push' && github.ref == 'refs/heads/main' && github.event.inputs.action != 'destroy')
      run: terraform apply -auto-approve tfplan
      
    - name: Terraform Destroy
      if: github.event.inputs.action == 'destroy'
      run: |
        echo "Running terraform destroy with full debug logs..."
        
        # Run destroy with refreshed state
        echo "Refreshing state before destroy..."
        terraform refresh
        
        # Force removal of autoscale settings again just to be safe
        RESOURCE_GROUP="${{ env.TF_VAR_existing_resource_group_name }}"
        for REGION in "us" "eu" "in"; do
          AUTOSCALE_NAME="autoscale-newsraag-${REGION}-prod"
          echo "Force removing $AUTOSCALE_NAME..."
          az monitor autoscale setting delete --name $AUTOSCALE_NAME --resource-group $RESOURCE_GROUP --yes 2>/dev/null || echo "Already removed"
        done
        
        # Run destroy with auto-approval
        TF_LOG=DEBUG terraform destroy -auto-approve
        
        # Verify resources are gone
        echo "Verifying resources have been destroyed..."
        REMAINING_AUTOSCALE=$(az monitor autoscale setting list --resource-group $RESOURCE_GROUP --query "[?contains(name, 'newsraag')].name" -o tsv 2>/dev/null || echo "")
        if [ -n "$REMAINING_AUTOSCALE" ]; then
          echo "WARNING: Some autoscale settings still exist. Forcing removal..."
          echo $REMAINING_AUTOSCALE | xargs -r -n 1 az monitor autoscale setting delete --name --resource-group $RESOURCE_GROUP --yes
        fi
        
    - name: Get Terraform Outputs
      if: github.event.inputs.action != 'destroy'
      id: terraform_outputs
      run: |
        echo "traffic_manager_url=$(terraform output -raw traffic_manager_url)" >> $GITHUB_OUTPUT
        echo "us_app_service_name=$(terraform output -raw us_app_service_name)" >> $GITHUB_OUTPUT
        echo "europe_app_service_name=$(terraform output -raw europe_app_service_name)" >> $GITHUB_OUTPUT
        echo "india_app_service_name=$(terraform output -raw india_app_service_name)" >> $GITHUB_OUTPUT
        echo "resource_group_name=$(terraform output -raw existing_resource_group_name)" >> $GITHUB_OUTPUT

  trigger_app_deployment:
    name: 'Trigger App Deployment'
    needs: terraform
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'destroy' && needs.terraform.outputs.traffic_manager_url != ''
    
    steps:
    - name: Trigger Multi-Region App Deployment
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.actions.createWorkflowDispatch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'deploy-app.yml',
            ref: 'main',
            inputs: {
              infrastructure_ready: 'true',
              us_app_name: '${{ needs.terraform.outputs.us_app_service_name }}',
              europe_app_name: '${{ needs.terraform.outputs.europe_app_service_name }}',
              india_app_name: '${{ needs.terraform.outputs.india_app_service_name }}',
              resource_group: '${{ needs.terraform.outputs.resource_group_name }}'
            }
          });